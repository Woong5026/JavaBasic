부모타입으로 자식객체를 참조하게 되면 부모가 가지고 있는 메소드만 사용할 수 있다. 

자식객체가 가지고 있는 메소드나 속성을 사용하고 싶다면 형변환 해야 한다.

**형변환**

```java

  public class Car{
        public void run(){
            System.out.println("Car의 run메소드");
        }
    }

    public class Bus extends Car{
        public void ppangppang(){
            System.out.println("빵빵.");
        }   
    }

```

상속관계란 is a 관계라고 말했었습니다. "Bus는 Car다." 라는 관계가 성립되는 것이죠.

현실에서도 우리는 버스를 가리키면서 차다. 라고 말하곤 합니다.

- 부모타입으로 자식객체를 참조할 수 있다.

부모타입으로 자식객체를 참조하게 되면 부모가 가지고 있는 메소드만 사용할 수 있다.

```java

public class BusExam{
        public static void main(String args[]){
            Car car = new Bus(); // 해당 코드는 부모가 자식을 참조만 하는 코드
            car.run();
            car.ppangppang(); // 컴파일 오류 발생, 부모클래스에는 없고 자식클래스에만 있으니까
        }
    }

```

ppangppang()메소드를 호출하고 싶다면 Bus타입의 참조변수로 참조해야 한다

Car(부모) 클래스가 상위에 존재하기에 큰 그릇 > 작은 그릇인 Car(큰 그릇) car = new Bus(); 는 가능하지만 Bus(작은 그릇) bus = car(); 는 불가능

그렇기에 형변환에서 배웠던 것처럼 

```java

public class BusExam{
        public static void main(String args[]){
            Car car = new Bus();
            car.run();
            //car.ppangppang(); // 컴파일 오류 발생

            **Bus bus = (Bus)car**;  //부모타입을 자식타입으로 형변환 
            bus.run();
            bus.ppangppang();
        }
    }
// Car타입의 car 라는 레퍼런스가 참조하는 것을 Bus 타입으로 변환시켜서 다시 Bus 타입의 래퍼런스인 bus가 참조하도록 설정
// 실제 생성되었을때 Car car = new Bus(); 였기 때문에 형변환이 가능했다. 만약 Car car = new Car(); 였으면 실행 x

```
부모타입으로 자식타입의 객체를 참조할 때는 묵시적으로 형변환이 일어난다.

부모타입의 객체를 자식타입으로 참조하게 할때는 명시적으로 형변환 해주어 한다. 

단 이렇게 형변환 할때에는 부모가 참조하는 인스턴스가 형변환 하려는 자식타입일 때만 가능하다.(Car car = new Bus(); 처럼)


